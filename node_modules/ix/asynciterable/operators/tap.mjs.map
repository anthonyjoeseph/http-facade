{"version":3,"sources":["asynciterable/operators/tap.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAGnD,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAC9D,OAAO,EAAE,mBAAmB,EAAE,MAAM,2BAA2B,CAAC;AAEhE,MAAM,OAAO,gBAA0B,SAAQ,cAAuB;IAC5D,OAAO,CAAyB;IAChC,SAAS,CAAgC;IAEjD,YAAY,MAA8B,EAAE,QAAuC;QACjF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAoB;QAChD,cAAc,CAAC,MAAM,CAAC,CAAC;QACvB,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC;QAC3B,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,CAAC;QACtD,IAAI;YACF,KAAK,IAAI,GAA4B,EAAE,CAAC,CAAC,GAAG,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,GAAI;gBACtE,IAAI,GAAG,CAAC,IAAI,EAAE;oBACZ,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;iBAC3B;gBACD,MAAM,GAAG,CAAC,KAAK,CAAC;aACjB;YACD,IAAI,GAAG,CAAC,QAAQ,EAAE;gBAChB,MAAM,GAAG,CAAC,QAAQ,EAAE,CAAC;aACtB;SACF;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,CAAC,CAAC,YAAY,UAAU,CAAC,IAAI,GAAG,CAAC,KAAK,EAAE;gBAC3C,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;aACpB;YACD,MAAM,CAAC,CAAC;SACT;gBAAS;YACR,MAAM,mBAAmB,CAAC,EAAE,CAAC,CAAC;SAC/B;IACH,CAAC;CACF;AAgCD;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,GAAG,CACjB,cAAiF,EACjF,KAAkC,EAClC,QAA6B;IAE7B,OAAO,SAAS,mBAAmB,CAAC,MAA8B;QAChE,OAAO,IAAI,gBAAgB,CAAU,MAAM,EAAE,UAAU,CAAC,cAAc,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC5F,CAAC,CAAC;AACJ,CAAC","file":"tap.js","sourcesContent":["import { AsyncIterableX } from '../asynciterablex';\nimport { PartialAsyncObserver } from '../../observer';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { toObserver } from '../../util/toobserver';\nimport { AbortError, throwIfAborted } from '../../aborterror';\nimport { returnAsyncIterator } from '../../util/returniterator';\n\nexport class TapAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _observer: PartialAsyncObserver<TSource>;\n\n  constructor(source: AsyncIterable<TSource>, observer: PartialAsyncObserver<TSource>) {\n    super();\n    this._source = source;\n    this._observer = observer;\n  }\n\n  async *[Symbol.asyncIterator](signal?: AbortSignal) {\n    throwIfAborted(signal);\n    const obs = this._observer;\n    const it = this._source[Symbol.asyncIterator](signal);\n    try {\n      for (let res: IteratorResult<TSource>; !(res = await it.next()).done; ) {\n        if (obs.next) {\n          await obs.next(res.value);\n        }\n        yield res.value;\n      }\n      if (obs.complete) {\n        await obs.complete();\n      }\n    } catch (e) {\n      if (!(e instanceof AbortError) && obs.error) {\n        await obs.error(e);\n      }\n      throw e;\n    } finally {\n      await returnAsyncIterator(it);\n    }\n  }\n}\n\n/**\n * Invokes an action for each element in the async-iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {PartialAsyncObserver<TSource>} observer Observer whose methods to invoke as part of the source sequence's observation.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  observer: PartialAsyncObserver<TSource>\n): MonoTypeOperatorAsyncFunction<TSource>;\n\n/**\n * Invokes an action for each element in the async-iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(((value: TSource) => any) | null)} [next] Function to invoke for each element in the async-iterable sequence.\n * @param {(((err: any) => any) | null)} [error] Function to invoke upon exceptional termination of the async-iterable sequence.\n * @param {((() => any) | null)} [complete] Function to invoke upon graceful termination of the async-iterable sequence.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  next?: ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorAsyncFunction<TSource>;\n\n/**\n * Invokes an action for each element in the async-iterable sequence, and propagates all observer\n * messages through the result sequence. This method can be used for debugging, logging, etc. by\n * intercepting the message stream to run arbitrary actions for messages on the pipeline.\n *\n * @template TSource The type of the elements in the source sequence.\n * @param {(PartialAsyncObserver<TSource> | ((value: TSource) => any) | null)} [observerOrNext] Observer whose methods to invoke as\n * part of the source sequence's observation or a function to invoke for each element in the async-iterable sequence.\n * @param {(((err: any) => any) | null)} [error] Function to invoke upon exceptional termination of the async-iterable sequence.\n * @param {((() => any) | null)} [complete] Function to invoke upon graceful termination of the async-iterable sequence.\n * @returns {MonoTypeOperatorAsyncFunction<TSource>} The source sequence with the side-effecting behavior applied.\n */\nexport function tap<TSource>(\n  observerOrNext?: PartialAsyncObserver<TSource> | ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function tapOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new TapAsyncIterable<TSource>(source, toObserver(observerOrNext, error, complete));\n  };\n}\n"]}